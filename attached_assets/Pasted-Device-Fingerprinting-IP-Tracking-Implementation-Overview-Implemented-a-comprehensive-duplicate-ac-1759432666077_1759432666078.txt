Device Fingerprinting & IP Tracking Implementation
Overview
Implemented a comprehensive duplicate account prevention system using device fingerprinting and IP address tracking to maintain the integrity of the Agorax digital democracy platform.

1. Database Schema Changes
Users Table Extensions
Added the following fields to the users table in shared/schema.ts:
// Device fingerprinting and IP tracking
deviceFingerprint: text("device_fingerprint"), // Browser fingerprint hash
registrationIp: text("registration_ip"), // IP address at signup
lastLoginIp: text("last_login_ip"), // Most recent login IP
accountFlags: jsonb("account_flags"), // JSON object for suspicious activity flags
accountStatus: text("account_status").default("active"), // 'active', 'flagged', or 'banned'

New Account Activity Table
Created a new accountActivity table to log all registration and login events:
export const accountActivity = pgTable("account_activity", {
id: serial("id").primaryKey(),
userId: integer("user_id").notNull().references(() => users.id),
deviceFingerprint: text("device_fingerprint"),
ipAddress: text("ip_address"),
action: text("action").notNull(), // 'registration', 'login', 'logout'
userAgent: text("user_agent"),
timestamp: timestamp("timestamp").notNull().defaultNow(),
});

Schema Relations
Added proper Drizzle ORM relations:
* Users have many accountActivity records
* Each accountActivity belongs to one user

2. Frontend Implementation
Library Installation
Installed @fingerprintjs/fingerprintjs for browser fingerprinting.
Device Fingerprint Capture (client/src/pages/auth-page.tsx)
Created a reusable fingerprint function:
import FingerprintJS from '@fingerprintjs/fingerprintjs';

const getFingerprint = async () => {
try {
const fp = await FingerprintJS.load();
const result = await fp.get();
return result.visitorId;
} catch (error) {
console.error('Fingerprint generation failed:', error);
return undefined;
}
};

Registration Flow Updates
Modified the registration form to:
1. Make handleSubmit async
2. Capture device fingerprint before submission
3. Include fingerprint in registration request:
const onSubmit = async (values: z.infer<typeof registerUserSchema>) => {
const deviceFingerprint = await getFingerprint();

registerMutation.mutate({
...values,
deviceFingerprint,
});
};

Login Flow Updates
Modified the login form similarly to:
1. Capture device fingerprint before login
2. Include fingerprint in login request
Updated schema validation:
// In shared/schema.ts
export const registerUserSchema = insertUserSchema.extend({
password: z.string().min(8),
email: z.string().email(),
name: z.string().min(2),
deviceFingerprint: z.string().optional(), // Handles blocked fingerprinting
});

export const loginUserSchema = z.object({
username: z.string(),
password: z.string(),
deviceFingerprint: z.string().optional(),
});


3. Backend Implementation
Registration Endpoint (server/auth.ts)
Enhanced /api/register to:
1. Extract Client IP Address:
const clientIp = (req.ip ||
req.headers['x-forwarded-for'] ||
req.connection.remoteAddress) as string;

2. Check for Duplicate Accounts (Hard Limit):
const deviceFingerprint = req.body.deviceFingerprint;

if (deviceFingerprint && clientIp) {
const duplicateCount = await storage.checkDuplicateAccounts(
deviceFingerprint,
clientIp
);

if (duplicateCount >= 3) {
return res.status(400).send(
"Έχετε φτάσει το όριο λογαριασμών από αυτήν τη συσκευή"
);
}
}

3. Create User with Tracking Data:
const user = await storage.createUser({
...userData,
password: await hashPassword(req.body.password),
deviceFingerprint: deviceFingerprint || null,
registrationIp: clientIp,
lastLoginIp: clientIp,
accountStatus: 'active'
});

4. Log Account Activity:
await storage.createAccountActivity({
userId: user.id,
deviceFingerprint: deviceFingerprint || null,
ipAddress: clientIp,
action: 'registration',
userAgent: req.headers['user-agent'] || null
});

Login Endpoint (server/auth.ts)
Enhanced /api/login to:
1. Check Account Status:
if (user.accountStatus === 'banned') {
return res.status(403).json({
message: "Ο λογαριασμός σας έχει αποκλειστεί"
});
}

2. Update Last Login IP:
const clientIp = (req.ip ||
req.headers['x-forwarded-for'] ||
req.connection.remoteAddress) as string;

await storage.updateUserLoginInfo(user.id, {
lastLoginIp: clientIp
});

3. Log Login Activity:
const deviceFingerprint = req.body.deviceFingerprint;

await storage.createAccountActivity({
userId: user.id,
deviceFingerprint: deviceFingerprint || null,
ipAddress: clientIp,
action: 'login',
userAgent: req.headers['user-agent'] || null
});


4. Storage Layer (server/storage.ts)
New Methods in IStorage Interface:
1. Check Duplicate Accounts:
checkDuplicateAccounts(deviceFingerprint: string, ip: string): Promise<number>

Implementation:
async checkDuplicateAccounts(deviceFingerprint: string, ip: string): Promise<number> {
const result = await db
.select({ count: count() })
.from(users)
.where(
and(
eq(users.deviceFingerprint, deviceFingerprint),
eq(users.registrationIp, ip)
)
);
return result[0]?.count || 0;
}

2. Create Account Activity:
createAccountActivity(activity: InsertAccountActivity): Promise<void>

Implementation:
async createAccountActivity(activity: InsertAccountActivity): Promise<void> {
await db.insert(accountActivity).values(activity);
}

3. Update User Login Info:
updateUserLoginInfo(userId: number, data: { lastLoginIp: string }): Promise<User>

Implementation:
async updateUserLoginInfo(userId: number, data: { lastLoginIp: string }): Promise<User> {
const [updated] = await db
.update(users)
.set({ lastLoginIp: data.lastLoginIp })
.where(eq(users.id, userId))
.returning();
return updated;
}

4. Get User Account Activity:
getUserAccountActivity(userId: number): Promise<AccountActivity[]>

5. Get All Users with Filters:
getAllUsersWithAccountInfo(filters?: { status?: string, search?: string }): Promise<User[]>

6. Update Account Status:
updateAccountStatus(userId: number, status: string): Promise<User>


5. Admin Dashboard (client/src/pages/admin-accounts.tsx)
Backend API Endpoints (server/routes.ts):
Protected with requireAdmin middleware:
1. GET /api/admin/accounts - List all users with filters
    * Query params: status, search
    * Returns: Array of users with full account info
2. GET /api/admin/accounts/:userId/activity - Get user activity history
    * Returns: Array of account activity records
3. POST /api/admin/accounts/:userId/ban - Ban a user
    * Sets accountStatus to 'banned'
4. POST /api/admin/accounts/:userId/approve - Approve a user
    * Sets accountStatus to 'active'
Frontend Admin Page Features:
User Management Table:
* Username, Email, Account Status (color-coded badges)
* Registration IP, Last Login IP
* Device Fingerprint (truncated to first 8 chars)
* Action buttons: View Activity, Ban/Approve
Filtering & Search:
* Status filter dropdown (All, Active, Flagged, Banned)
* Search by username or email
Activity Modal:
* Shows complete activity history for selected user
* Displays: Action type, IP Address, Device Fingerprint, Timestamp
* Sorted by most recent first
Status Badges:
* Green = Active
* Yellow = Flagged
* Red = Banned
Navigation:
Added "Account Management" link to header dropdown menu (admin users only)

6. Security Features
Hard Limits:
* Maximum 3 accounts per device fingerprint + IP combination
* 4th registration attempt is blocked with error message
Soft Detection:
* All activity logged for audit trail
* Admins can review suspicious patterns
* Manual ban/approve functionality
Account Status Flow:
1. Active - Normal user (default)
2. Flagged - Suspicious activity detected (for future enhancements)
3. Banned - Cannot log in, blocked from platform
Audit Trail:
* Every registration and login tracked
* Device fingerprint captured
* IP address logged
* User agent stored
* Timestamp recorded

7. Edge Cases Handled
1. Fingerprinting Blocked:
* Some browsers block fingerprinting
* System gracefully handles undefined fingerprints
* Uses || null fallbacks to prevent errors
2. IP Address Extraction:
* Multiple fallback sources for IP detection:
    * req.ip (when behind proxy)
    * x-forwarded-for header
    * req.connection.remoteAddress
3. Family Members on Same Network:
* Different browsers/devices = different fingerprints
* Won't be blocked even with same IP
4. VPN Users:
* IP may change frequently
* Fingerprint remains consistent per device
* Detection based on fingerprint + IP combination

8. How It Works Together
Registration Flow:
1. User fills registration form
2. Frontend captures device fingerprint
3. Backend extracts IP address
4. System checks for existing accounts with same fingerprint + IP
5. If count ≥ 3, registration is blocked
6. Otherwise, user created with tracking data
7. Activity logged to accountActivity table
Login Flow:
1. User submits login credentials
2. Frontend captures device fingerprint
3. Backend validates credentials
4. Checks if account is banned
5. Updates lastLoginIp
6. Logs login activity
7. User authenticated
Admin Monitoring:
1. Admin navigates to Account Management
2. Views all users with fingerprint/IP data
3. Can search/filter accounts
4. Reviews activity history for suspicious users
5. Bans or approves accounts as needed

9. Database Migration
Used Drizzle ORM with the following command:
npm run db:push --force

This safely synced the schema changes to the database.

10. Technical Stack
* Fingerprinting: @fingerprintjs/fingerprintjs (browser-based)
* Database: PostgreSQL with Drizzle ORM
* Backend: Express.js with session management
* Frontend: React with TanStack Query
* UI Components: shadcn/ui (Table, Badge, Dialog, etc.)
* Validation: Zod schemas
* Date Formatting: date-fns with Greek locale

Summary
The system provides a balanced approach to duplicate account prevention:
* Hard enforcement: Blocks obvious abuse (3+ accounts)
* Soft monitoring: Logs all activity for review
* Admin control: Manual oversight and management
* User-friendly: Handles edge cases gracefully
This implementation deters casual duplicate accounts while allowing legitimate use cases (family members, multiple devices, VPN users).
