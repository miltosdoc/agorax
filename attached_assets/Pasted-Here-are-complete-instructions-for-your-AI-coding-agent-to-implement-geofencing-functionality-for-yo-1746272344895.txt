Here are complete instructions for your AI coding agent to implement geofencing functionality for your polling website:

**Context**: You have a polling website where users can create and vote on polls. Currently, polls can be either global (no restrictions) or location-based using device GPS. You want to enhance this by allowing poll creators to define a geographic area (using postal codes or map pins with a radius) where only users within that area can vote.

**Implementation Instructions**:

**1. Database Modifications**
```sql
-- Add geofencing columns to your existing polls table
ALTER TABLE polls ADD COLUMN center_lat DECIMAL(10, 8);
ALTER TABLE polls ADD COLUMN center_lng DECIMAL(11, 8);
ALTER TABLE polls ADD COLUMN radius_km INTEGER;
-- These will be NULL for global polls (maintaining backward compatibility)
```

**2. Frontend Dependencies**
Add Leaflet.js (free, open-source mapping library) to your poll creation page:
```html
<!-- In <head> section -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
```

**3. Poll Creation Page Updates**
Add a map interface to your existing poll creation form:
```html
<!-- Add this section to your poll creation form -->
<div class="location-settings">
    <label>
        <input type="radio" name="location-type" value="global" checked> Global (no restrictions)
    </label>
    <label>
        <input type="radio" name="location-type" value="geofenced"> Location-based
    </label>
    
    <div id="geofence-controls" style="display: none;">
        <div id="map" style="height: 400px; margin: 10px 0;"></div>
        
        <div class="location-inputs">
            <input type="text" id="postal-code" placeholder="Enter postal code">
            <button onclick="searchPostalCode()">Search</button>
            
            <label>Radius (km): 
                <input type="number" id="radius-input" value="5" min="1" max="100">
            </label>
        </div>
        
        <!-- Hidden fields to store selected location -->
        <input type="hidden" name="center_lat" id="center_lat">
        <input type="hidden" name="center_lng" id="center_lng">
        <input type="hidden" name="radius_km" id="radius_km">
    </div>
</div>
```

**4. JavaScript for Map Functionality**
```javascript
// Initialize map when location-based is selected
let map, marker, circle;

document.querySelector('input[value="geofenced"]').addEventListener('change', function() {
    document.getElementById('geofence-controls').style.display = 'block';
    if (!map) {
        map = L.map('map').setView([0, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors'
        }).addTo(map);
        
        // Handle map clicks
        map.on('click', function(e) {
            placeMarker(e.latlng.lat, e.latlng.lng);
        });
    }
});

document.querySelector('input[value="global"]').addEventListener('change', function() {
    document.getElementById('geofence-controls').style.display = 'none';
});

function placeMarker(lat, lng) {
    if (marker) map.removeLayer(marker);
    if (circle) map.removeLayer(circle);
    
    marker = L.marker([lat, lng]).addTo(map);
    
    // Update hidden fields
    document.getElementById('center_lat').value = lat;
    document.getElementById('center_lng').value = lng;
    
    updateRadius();
}

function updateRadius() {
    const radius = document.getElementById('radius-input').value;
    document.getElementById('radius_km').value = radius;
    
    if (circle) map.removeLayer(circle);
    
    const lat = document.getElementById('center_lat').value;
    const lng = document.getElementById('center_lng').value;
    
    if (lat && lng) {
        circle = L.circle([lat, lng], {
            radius: radius * 1000,
            color: 'blue',
            fillOpacity: 0.1
        }).addTo(map);
    }
}

// Postal code search
async function searchPostalCode() {
    const postalCode = document.getElementById('postal-code').value;
    if (!postalCode) return;
    
    try {
        const response = await fetch(`https://nominatim.openstreetmap.org/search?postalcode=${postalCode}&format=json&limit=1`);
        const data = await response.json();
        
        if (data.length > 0) {
            const lat = parseFloat(data[0].lat);
            const lng = parseFloat(data[0].lon);
            
            map.setView([lat, lng], 12);
            placeMarker(lat, lng);
        } else {
            alert('Postal code not found');
        }
    } catch (error) {
        console.error('Geocoding error:', error);
    }
}

// Radius input change handler
document.getElementById('radius-input').addEventListener('change', updateRadius);
```

**5. Backend Poll Creation Handler**
Update your existing poll creation endpoint to handle the new location fields:
```javascript
// In your poll creation handler
if (req.body.location_type === 'geofenced') {
    poll.center_lat = req.body.center_lat;
    poll.center_lng = req.body.center_lng;
    poll.radius_km = req.body.radius_km;
} else {
    // Global poll - leave location fields as NULL
    poll.center_lat = null;
    poll.center_lng = null;
    poll.radius_km = null;
}
```

**6. Voting Validation Logic**
Update your voting endpoint to check geofencing:
```javascript
// Haversine distance calculation function
function calculateDistance(lat1, lon1, lat2, lon2) {
    const R = 6371; // Earth radius in km
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = 
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
        Math.sin(dLon/2) * Math.sin(dLon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
}

// In your voting handler
async function validateVote(pollId, userLat, userLng) {
    const poll = await getPollById(pollId);
    
    // If poll has no geofence (global), allow voting
    if (!poll.center_lat || !poll.center_lng || !poll.radius_km) {
        return true;
    }
    
    // Calculate distance from user to poll center
    const distance = calculateDistance(
        userLat, userLng, 
        poll.center_lat, poll.center_lng
    );
    
    // Check if user is within radius
    return distance <= poll.radius_km;
}
```

**7. Frontend Voting Check**
Update your voting page to get user location and validate:
```javascript
function attemptVote(pollId) {
    if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
            position => {
                const userLat = position.coords.latitude;
                const userLng = position.coords.longitude;
                
                // Send vote request with location
                submitVote(pollId, userLat, userLng);
            },
            error => {
                alert('Location access required for this poll');
            }
        );
    } else {
        alert('Geolocation not supported by your browser');
    }
}
```

**Summary**:
- Uses free OpenStreetMap tiles and Nominatim geocoding
- No API keys required
- Minimal database changes (3 new columns)
- Backward compatible with existing global polls
- Client-side distance calculations reduce server load
- Total implementation cost: $0

This solution maintains your existing functionality while adding the requested geofencing feature in the most cost-effective way possible.